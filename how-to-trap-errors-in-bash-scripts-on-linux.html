<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>How to Trap Errors in Bash Scripts on Linux -</title><meta name=robots content="index,follow,noarchive"><meta name=description content="Quick LinksError Handling in Scripts  Detecting the Exit Status  Using set To Force an Exit  Using trap With Errors  A Final Tip   By default, a Bash script on Linux will report an error but keep running. We show you how to handle errors yourself so that you can decide what needs to happen next.
  Error Handling in Scripts  Handling errors is part of programming."><meta name=author content="Aldo Pusey"><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/app.css><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/an-old-hope.min.css><script defer src=https://assets.cdnweb.info/hugo/paper/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=./theme.png><link rel=icon href=./favicon.ico><link rel=apple-touch-icon href=./apple-touch-icon.png><meta name=generator content="Hugo 0.98.0"><meta property="og:title" content="How to Trap Errors in Bash Scripts on Linux"><meta property="og:description" content="By default, a Bash script on Linux will report an error but keep running. We show you how to handle errors yourself so that you can decide what needs to happen next. Handling errors is part of programming. Even if you write flawless code, you can still run into error conditions. The environment on your"><meta property="og:type" content="article"><meta property="og:url" content="/how-to-trap-errors-in-bash-scripts-on-linux.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-07T00:00:00+00:00"><meta itemprop=name content="How to Trap Errors in Bash Scripts on Linux"><meta itemprop=description content="By default, a Bash script on Linux will report an error but keep running. We show you how to handle errors yourself so that you can decide what needs to happen next. Handling errors is part of programming. Even if you write flawless code, you can still run into error conditions. The environment on your"><meta itemprop=datePublished content="2024-07-07T00:00:00+00:00"><meta itemprop=dateModified content="2024-07-07T00:00:00+00:00"><meta itemprop=wordCount content="1670"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="How to Trap Errors in Bash Scripts on Linux"><meta name=twitter:description content="By default, a Bash script on Linux will report an error but keep running. We show you how to handle errors yourself so that you can decide what needs to happen next. Handling errors is part of programming. Even if you write flawless code, you can still run into error conditions. The environment on your"></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=./index.html>ZenVlog</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=./sitemap.xml>Sitemap</a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Jul 7, 2024</time>
<span>Aldo Pusey</span></p><h1>How to Trap Errors in Bash Scripts on Linux</h1></header><section class=post-content><h3>Quick Links</h3><ul class=table-content-level-1><li><a href=#>Error Handling in Scripts</a></li></ul><ul class=table-content-level-1><li><a href=#>Detecting the Exit Status</a></li></ul><ul class=table-content-level-1><li><a href=#>Using set To Force an Exit</a></li></ul><ul class=table-content-level-1><li><a href=#>Using trap With Errors</a></li></ul><ul class=table-content-level-1><li><a href=#>A Final Tip</a></li></ul><p>By default, a Bash script on Linux will report an error but keep running. We show you how to handle errors yourself so that you can decide what needs to happen next.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=error-handling-in-scripts>Error Handling in Scripts</h2><p>Handling errors is part of programming. Even if you write flawless code, you can still run into error conditions. The environment on your computer changes over time, as you install and uninstall software, <a href=#>create directories</a>, and perform upgrades and updates.</p><p>For example, a script that used to run without issue can run into difficulties if <a href=#>directory paths change</a>, or <a href=#>permissions are changed on a file</a>. The default action of the Bash shell is to print an error message and continue to execute the script. This is a dangerous default.</p><p>If the action that failed is critical to some other processing or action that happens later in your script, that critical action will not be successful. How disastrous that turns out to be, depends on what your script is trying to do.</p><p>A more robust scheme would detect errors and let the script work out if it needed to shut down or try to remedy the fault condition. For example, if a directory or file is missing it may be satisfactory to have the script recreate them.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>If the script has encountered a problem from which it cannot recover, it can shut down. If the script has to shut down, it can have the chance to perform whatever clean-up is required, such as removing temporary files or writing the error condition and shutdown reason to a log file.</p><h2 id=detecting-the-exit-status>Detecting the Exit Status</h2><p>Commands and programs generate a value that is sent to the operating system when they terminate. This is called <a href=#>their exit status</a>. It has a value of zero if there were no errors, or some non-zero value if an error occurred.</p><p>We can check the exit status---also known as a return code---of the commands the script uses, and determine whether the command was successful or not.</p><p>In Bash, zero equates to true. If the response from the command is anything other than true, we know a problem has occurred and we can take appropriate action.</p><p>Copy this script into an editor, and save it to a file called "bad_command.sh."</p><pre>#!/bin/bash <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong>  <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong>  <p>if ( ! bad_command ); then</p>  <p>&nbsp; echo "bad_command flagged an error."</p>  <p>&nbsp; exit 1</p>  <p>fi</p></pre><p>You'll need to make the script executable with the <code>chmod</code> command. This is a step that's required to make any script executable, so if you want to try the scripts out on your own machine, remember to do this for each of them. Substitute the name of the appropriate script in each case.</p><pre>chmod +x bad_command.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/07/1-8.png><p>When we run the script we see the expected error message.</p><pre>./bad_command.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/07/2-8.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>There's no such command as "bad_command", nor is it the name of a function within the script. It cannot be executed, so the response is not zero. If the response is not zero---the exclamation point is used here as the logical <code>NOT</code> operator---the body of the <code>if</code> statement is executed.</p><p>In a real-world script, this could terminate the script, which our example does, or it could try to remedy the fault condition.</p><p>It might look like the <code>exit 1</code> line is redundant. After all, there's nothing else in the script and it is going to terminate anyway. But using the <code>exit</code> command allows us to pass an exit status back to the shell. If our script is ever called from within a second script, that second script will know that this script encountered errors.</p><p>You can use the logical <code>OR</code> operator with the exit status of a command, and call another command or a function in your script if there is a non-zero response from the first command.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><pre>command_1 || command_2</pre><p>This works because either the first command runs <code>OR</code> the second. The left-most command is run first. If it succeeds the second command is not executed. But if the first command fails, the second command is executed. So we can structure code like this. This is "logical-or./sh."</p><pre>#!/bin/bash  <p>error_handler()</p>  <p>{</p>  <p>&nbsp; echo "Error: ($?) $1"</p>  <p>&nbsp; exit 1</p>  <p>}</p>  <p>bad_command || error_handler "bad_command failed, Line: ${LINENO}"</p></pre><p>We've defined a function called <code>error_handler</code> . This prints out the exit status of the failed command, held in the variable <code>$?</code>&nbsp;and a line of text that is passed to it when the function is called. This is held in the variable <code>$1</code>. The function terminates the script with an exit status of one.</p><p>The script tries to run <code>bad_command</code> which obviously fails, so the command to the right of the logical <code>OR</code> operator, <code>||</code>, is executed. This calls the <code>error_handler</code> function and passes a string that names the command that failed, and contains the line number of the failing command.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>We'll run the script to see the error handler message, and then check the exit status of the script using echo.</p><pre>./logical-or.sh</pre><pre>echo $?</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/07/3-8.png><p>Our little <code>error_handler</code> function provides the exit status of the attempt to run <code>bad_command</code>, the name of the command, and the line number. This is useful information when you're debugging a script.</p><p>The exit status of the script is one. The 127 exit status reported by <code>error_handler</code> means "command not found." If we wanted, we could use that as the exit status of the script by passing it to the <code>exit</code> command.</p><p>Another approach would be to expand <code>error_handler</code> to check for the different possible values of the exit status and to perform different actions accordingly, using this type of construct:</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><pre>exit_code=$?  <p>if [ $exit_code -eq 1 ]; then</p>  <p> echo "Operation not permitted"</p>  <p>elif [ $exit_code -eq 2 ]; then</p>  <p> echo "Misuse of shell builtins"</p>  <p>.</p>  <p>.</p>  <p>.</p>  <p>elif [ $status -eq 128 ]; then</p>  <p> echo "Invalid argument"</p>  <p>fi</p></pre><h2 id=using-set-to-force-an-exit>Using set To Force an Exit</h2><p>If you know that you want your script to exit whenever there is an error, you can force it to do that. it means you forgo the chance of any cleanup---or any further damage, too---because your script terminates as soon as it detects an error.</p><p>To do this, use <a href=#>the <code>set</code> command</a> with the <code>-e</code> (error) option. This tells the script to exit whenever a command fails or returns an exit code greater than zero. Also, using the <code>-E</code> option ensures the error detection and trapping works in shell functions.</p><p><span class=related-single>Related: <a href=#>Fix: "Bad Interpreter: No Such File or Directory" Error in Linux</a></span></p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>To also catch uninitialized variables, add the <code>-u</code> (unset) option. To make sure that errors are detected in piped sequences, add the <code>-o pipefail</code> option. Without this, the exit status of a piped sequence of commands is the exit status of the final command in the sequence. A failing command in the middle of the piped sequence would not be detected. The <code>-o pipefail</code> option must come in the list of options.</p><p>The sequence to add to the top of your script is:</p><pre>set -Eeuo pipefail</pre><p>Here's a short script called "unset-var.sh", with an unset variable in it.</p><pre>#!/bin/bash  <p>set -Eeou pipefail</p>  <p>echo "$unset_variable"</p>  <p>echo "Do we see this line?"</p></pre><p>When we run the script the unset_variable is recognized as an uninitialized variable and the script is terminated.</p><pre>./unset-var.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/07/4-9.png><p>The second <code>echo</code> command is never executed.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=using-trap-with-errors>Using trap With Errors</h2><p>The Bash trap command lets you nominate a command or a function that should be called when a particular signal is raised. Typically this is used to catch signals such as <code>SIGINT</code> which is raised when you press the Ctrl+C key combination. This script is "sigint.sh."</p><pre>#!/bin/bash  <p>trap "echo -e '\nTerminated by Ctrl+c'; exit" SIGINT</p>  <p>counter=0</p>  <p>while true</p>  <p>do </p>  <p> echo "Loop number:" $((++counter))</p>  <p> sleep 1</p>  <p>done</p></pre><p>The <code>trap</code> command contains an <code>echo</code> command and the <code>exit</code> command. It will be triggered when <code>SIGINT</code> is raised. The rest of the script is a simple loop. If you run the script and hit Ctrl+C you'll see the message from the <code>trap</code> definition, and the script will terminate.</p><pre>./sigint.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/07/5-8.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>We can use <code>trap</code> with the <code>ERR</code> signal to catch errors as they occur. These can then be fed to a command or function. This is "trap.sh." We're sending error notifications to a function called <code>error_handler</code>.</p><pre>#!/bin/bash  <p>trap 'error_handler $? $LINENO' ERR</p>  <p>error_handler() {</p>  <p> echo "Error: ($1) occurred on $2"</p>  <p>}</p>  <p>main() {</p>  <p> echo "Inside main() function"</p>  <p> bad_command</p>  <p> second</p>  <p> third</p>  <p> exit $?</p>  <p>}</p>  <p>second() {</p>  <p> echo "After call to main()"</p>  <p> echo "Inside second() function"</p>  <p>}</p>  <p>third() {</p>  <p> echo "Inside third() function"</p>  <p>}</p>  <p>main</p></pre><p>The bulk of the script is inside the <code>main</code> function, which calls the <code>second</code> and <code>third</code> functions. When an error is encountered---in this case, because <code>bad_command</code> doesn't exist---the <code>trap</code> statement directs the error to the <code>error_handler</code> function. It passes the exit status from the failed command and the line number to the <code>error_handler</code> function.</p><pre>./trap.sh</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/07/6-9.png><p>Our <code>error_handler</code> function simply lists the details of the error to the terminal window. If you wanted, you could add an <code>exit</code> command to the function to have the script terminate. Or you could use a series of <code>if/elif/fi</code> statements to perform different actions for different errors.</p><p>It might be possible to remedy some errors, others might require the script to halt.</p><h2 id=a-final-tip>A Final Tip</h2><p>Catching errors often means pre-empting the things that can go wrong, and putting in code to handle those eventualities should they arise. That's in addition to making sure the execution flow and internal logic of your script are correct.</p><p>If you use this command to run your script Bash will show you a trace output as the script executes:</p><pre>bash -x your-script.sh</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>Bash writes the trace output in the terminal window. It shows each&nbsp;command with its arguments---if it has any. This happens after the commands have been expanded but before they are executed.</p><p>It can be a tremendous help in tracking down elusive <a href=#>bugs</a>.</p><p><span class=related-single>Related: <a href=#>How to Validate the Syntax of a Linux Bash Script Before Running It</a></span></p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7qbvWraagnZWge6S7zGhva2ljZ31wtM6wZK2nXam%2ForyMnqmrp6Koeqq6jJuYrKBdqLCztc%2BtqmannmK5qrrUsWY%3D</p></section><nav class=post-nav><a class=prev href=./how-to-get-rid-of-bloating-7569329.html><span>←</span><span>How to Get Rid of Bloating, According to Experts</span></a>
<a class=next href=./murad-deep-relief-acne-treatment-review.html><span>Murad Deep Relief Acne Treatment Review: What I Really Think</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=./></a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>